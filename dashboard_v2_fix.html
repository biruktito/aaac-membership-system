<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AAAC Dashboard v2 FIX (Firestore)</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background:#f8fafc; color:#0f172a; }
    header { padding: 16px; background:#0ea5e9; color:white; }
    main { padding: 16px; max-width: 1100px; margin: 0 auto; }
    .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; margin: 12px 0; }
    .card { background:white; border-radius: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); padding: 14px; }
    .row { display:flex; gap: 10px; align-items:center; }
    .list { display:grid; gap:8px; margin-top: 16px; }
    .member { background:white; border:1px solid #e2e8f0; border-radius:8px; padding:12px; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; font-size: 12px; }
    .badge.current{ background:#dcfce7; color:#166534; }
    .badge.behind{ background:#fee2e2; color:#991b1b; }
    .muted { color:#475569; font-size: 13px; }
    button { background:#0ea5e9; color:white; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; }
    button.secondary { background:#e2e8f0; color:#0f172a; }
    .warn { color:#b91c1c; }
    .green { color:#166534; }
  </style>

  <!-- Firebase compat SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>

  <!-- Inline config fallback to avoid Pages loading issues -->
  <script>
    window.firebaseConfig = window.firebaseConfig || {
      apiKey: "AIzaSyDa4rimRWUUgPp7LAAaZzyrn13MKM-9naA",
      authDomain: "aaac-membership-1221.firebaseapp.com",
      projectId: "aaac-membership-1221",
      storageBucket: "aaac-membership-1221.firebasestorage.app",
      messagingSenderId: "134230731518",
      appId: "1:134230731518:web:2eb24bfa5cb9e9df2453af",
      measurementId: "G-YJJD19WXBG",
    };
  </script>
  <!-- NOTE: On root page, reference the docs/ path for init file -->
  <script src="docs/firebase-init.js"></script>
</head>
<body>
  <header>
    <div class="row" style="justify-content: space-between;">
      <div>
        <div style="font-weight:700; font-size:18px;">AAAC Membership System — v2 FIX (Firestore)</div>
        <div class="muted">Real-time, single source of truth. September 2025 calculations.</div>
      </div>
      <div class="row">
        <button id="btnSignInEmail" class="secondary">Sign in (Email)</button>
        <button id="btnClaimPhoneId" class="secondary">Sign in (Phone+ID)</button>
        <button id="btnSignOut" class="secondary" style="display:none;">Sign out</button>
        <span id="roleBadge" class="muted" style="margin-left:12px; font-weight:600;"></span>
      </div>
    </div>
  </header>

  <main>
    <div class="cards">
      <div class="card"><div>Total Members</div><div id="statTotal" style="font-size:24px; font-weight:700;">—</div></div>
      <div class="card"><div>Current</div><div id="statCurrent" style="font-size:24px; font-weight:700;">—</div></div>
      <div class="card"><div>Behind</div><div id="statBehind" style="font-size:24px; font-weight:700;">—</div></div>
      <div class="card"><div>Owed by Active</div><div id="statOwed" style="font-size:24px; font-weight:700;">—</div></div>
    </div>

    <div class="row" style="gap:8px;">
      <input id="search" placeholder="Search members by name..." style="flex:1; padding:10px; border:1px solid #cbd5e1; border-radius:8px;" />
      <select id="filterStatus" style="padding:10px; border:1px solid #cbd5e1; border-radius:8px;">
        <option value="all">All</option>
        <option value="current">Current</option>
        <option value="behind">Behind</option>
        <option value="issue">Issue</option>
        <option value="risk">Risk</option>
        <option value="inactive">Inactive</option>
      </select>
      <button id="refresh">Recalculate</button>
    </div>

    <div id="list" class="list"></div>
  </main>

  <!-- Record Payment Modal -->
  <div id="paymentModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.4); align-items:center; justify-content:center;">
    <div style="background:#fff; padding:16px; border-radius:10px; width:100%; max-width:420px; box-shadow:0 10px 30px rgba(0,0,0,0.15);">
      <div style="font-weight:700; font-size:16px;">Record Payment</div>
      <div id="pmember" class="muted" style="margin:6px 0 12px;"></div>
      <div style="display:flex; gap:8px;">
        <input id="pamount" type="number" min="0" step="0.01" placeholder="$ Amount" style="flex:1; padding:10px; border:1px solid #cbd5e1; border-radius:8px;" />
        <select id="ptype" style="padding:10px; border:1px solid #cbd5e1; border-radius:8px;">
          <option value="monthly">Monthly Dues</option>
          <option value="incidental">Incidental</option>
          <option value="registration">Registration</option>
        </select>
      </div>
      <div id="ppreview" class="muted" style="margin-top:8px; font-size:13px;"></div>
      <div style="display:flex; gap:8px; margin-top:12px;">
        <button id="psave">Save</button>
        <button id="pcancel" class="secondary">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    const CURRENT_DATE = new Date('2025-09-01T00:00:00Z');
    const DUE_PER_MONTH = 15; // USD
    const USE_LOCAL_ONLY = false; // Firestore is the single source of truth for v2

    function monthKey(date) { return `${date.getUTCFullYear()}-${String(date.getUTCMonth()+1).padStart(2,'0')}`; }

    function calculateMemberFinancials(member) {
      // Accept both Firestore map and local JSON paymentsDues
      const payments = member.payments || member.paymentsDues || {};
      
      // Find first payment month from actual payments
      const firstPaymentMonth = findFirstPaymentDate(payments);
      if (!firstPaymentMonth) {
        return { 
          totalOwed: 0, 
          totalPaid: 0, 
          balance: 0, 
          monthsBehind: 0, 
          paidUpTo: null, 
          status: 'inactive',
          startAt: null
        };
      }
      
      // Baseline = max(member.startDate, firstPaymentMonth) as per memory
      const memberStartDate = member.startDate ? new Date(member.startDate + 'T00:00:00Z') : null;
      const firstPaymentDate = new Date(firstPaymentMonth + 'T00:00:00Z');
      const baseline = memberStartDate && memberStartDate > firstPaymentDate ? memberStartDate : firstPaymentDate;
      
      // Calculate owed months from baseline to current (inclusive)
      const start = new Date(Date.UTC(baseline.getUTCFullYear(), baseline.getUTCMonth(), 1));
      const end = new Date(Date.UTC(CURRENT_DATE.getUTCFullYear(), CURRENT_DATE.getUTCMonth(), 1));
      
      let totalOwed = 0;
      let totalPaidTowardOwed = 0;
      let monthsCovered = 0;
      let paidUpTo = null;
      
      // Calculate owed months and payments within the owed window
      const iter = new Date(start);
      while (iter <= end) {
        const key = monthKey(iter);
        const paid = Number(payments[key] || 0);
        totalOwed += DUE_PER_MONTH;
        totalPaidTowardOwed += paid;
        
        if (paid >= DUE_PER_MONTH) {
          monthsCovered += 1;
          paidUpTo = new Date(iter);
        }
        
        iter.setUTCMonth(iter.getUTCMonth() + 1);
      }
      
      // Calculate future credit (payments beyond current month)
      let futureCredit = 0;
      try {
        Object.keys(payments).forEach(k => {
          const [yy, mm] = k.split('-');
          const d = new Date(`${yy}-${mm}-01T00:00:00Z`);
          if (d > end) futureCredit += Number(payments[k] || 0);
        });
      } catch(_) {}
      
      // Calculate months behind and balance
      const owedMonths = Math.floor((end - start) / (1000 * 60 * 60 * 24 * 30.44)) + 1; // Approximate months
      const monthsBehind = Math.max(0, owedMonths - monthsCovered);
      const balance = (totalPaidTowardOwed + futureCredit) - totalOwed;
      
      // Find latest month with payment >= $15 (even if future)
      let paidUpToAny = paidUpTo;
      try {
        let maxD = null;
        Object.keys(payments).forEach(k => {
          const amount = Number(payments[k] || 0);
          if (amount >= DUE_PER_MONTH) {
            const [yy, mm] = k.split('-');
            const d = new Date(`${yy}-${mm}-01T00:00:00Z`);
            if (!maxD || d > maxD) maxD = d;
          }
        });
        if (maxD) paidUpToAny = maxD;
      } catch(_) {}
      
      // Determine status based on our memory rules
      let status = 'current';
      
      // Check for inactive (manual flag)
      if (!member.isActive) {
        status = 'inactive';
      }
      // Check for inactive (lapsed - no payment in last 36 months)
      else if (paidUpToAny) {
        const lastPaymentDate = new Date(paidUpToAny);
        const thirtySixMonthsAgo = new Date(CURRENT_DATE);
        thirtySixMonthsAgo.setUTCMonth(thirtySixMonthsAgo.getUTCMonth() - 36);
        if (lastPaymentDate < thirtySixMonthsAgo) {
          status = 'inactive';
        }
      }
      // Check for arrears status
      else if (balance < 0) {
        if (monthsBehind >= 6) status = 'risk';
        else if (monthsBehind >= 3) status = 'issue';
        else if (monthsBehind >= 1) status = 'behind';
        else status = 'current';
      } else if (balance > 0) {
        status = 'ahead';
      }

      return { 
        balance, 
        monthsBehind, 
        paidUpTo: paidUpToAny, 
        status, 
        totalOwed, 
        totalPaid: totalPaidTowardOwed + futureCredit,
        startAt: baseline
      };
    }
    
    function findFirstPaymentDate(payments) {
      const paymentDates = Object.keys(payments).filter(key => 
        /^\d{4}-\d{2}$/.test(key) && Number(payments[key]) > 0
      ).sort();
      return paymentDates.length > 0 ? paymentDates[0] + '-01' : null;
    }

    function renderStats(members) {
      let total = members.length;
      let current = 0; let behind = 0; let owed = 0;

      // Active definition: any payment in the last 36 months
      const isActiveDerived = (m) => {
        const payments = m.payments || m.paymentsDues || {};
        const keys = Object.keys(payments);
        if (!keys.length) return false;
        const threshold = new Date('2022-10-01T00:00:00Z'); // 36 months before 2025-09 is 2022-10
        return keys.some(k => {
          const [y, mm] = k.split('-');
          const d = new Date(`${y}-${mm}-01T00:00:00Z`);
          return payments[k] > 0 && d >= threshold;
        });
      };
      members.forEach(m => {
        const f = calculateMemberFinancials(m);
        if (isActiveDerived(m)) {
          if (f.balance < 0) owed += Math.abs(f.balance);
          if (f.balance >= 0) current += 1; else behind += 1;
        }
      });
      document.getElementById('statTotal').textContent = total;
      document.getElementById('statCurrent').textContent = current;
      document.getElementById('statBehind').textContent = behind;
      document.getElementById('statOwed').textContent = `$${owed.toFixed(2)}`;
    }

    function formatPaidUpTo(date) {
      if (!date) return 'Not Started';
      return date.toLocaleString('en-US', { month: 'long', year: 'numeric', timeZone: 'UTC' });
    }

    function renderList(members) {
      const q = document.getElementById('search').value.trim().toLowerCase();
      const f = document.getElementById('filterStatus').value;
      const container = document.getElementById('list');
      container.innerHTML = '';
      // Sort by numeric memberId ascending for stable display
      const sorted = [...members].sort((a,b) => {
        const ai = parseInt(String(a.memberId || a.id || 0), 10) || 0;
        const bi = parseInt(String(b.memberId || b.id || 0), 10) || 0;
        return ai - bi;
      });
      sorted
        .filter(m => {
          if (!q) return true;
          const name = (m.fullName || '').toLowerCase();
          const id = String(m.memberId || m.id || '').toLowerCase();
          return name.includes(q) || id.includes(q);
        })
        .slice(0, 250)
        .forEach(m => {
          const f = calculateMemberFinancials(m);
          const sel = document.getElementById('filterStatus').value;
          if (sel !== 'all') {
            const effective = (f.status === 'ahead') ? 'current' : f.status;
            if (effective !== sel) return;
          }
          const div = document.createElement('div');
          div.className = 'member';
          const statusClass = (f.status === 'current' || f.status === 'ahead') ? 'current' : 'behind';
          const balanceEl = f.balance < 0 ? `<span class="warn">-$${Math.abs(f.balance).toFixed(2)}</span>` : `<span class="green">$${f.balance.toFixed(2)}</span>`;
          // Admin actions (visible when signed-in email user)
          const role = window.__role || 'member';
          const isAdmin = role === 'admin';
          const isBoard = role === 'board';
          const actions = (isAdmin || isBoard) ? `
            <div class="row" style="gap:8px; margin-top:8px;">
              ${isAdmin ? `<button data-action="record" data-id="${m.id}">Record Payment</button>` : ''}
              <button class="secondary" data-action="remind" data-id="${m.id}">Generate Reminder</button>
            </div>
          ` : '';
          const startChip = f.startAt ? 
            `Start: ${f.startAt.toLocaleString('en-US', { month: 'short', year: 'numeric', timeZone: 'UTC' })}` : 
            'Start: —';
          div.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <div>
                <div style="font-weight:600;">${m.fullName || 'Unnamed'}</div>
                <div class="muted">Member ID: ${m.memberId || '—'}</div>
              </div>
              <span class="badge ${statusClass}">${f.status}</span>
            </div>
            <div class="muted" style="margin-top:6px;">${startChip} • Balance: ${balanceEl} • Months behind: ${f.monthsBehind} • Paid up to: ${formatPaidUpTo(f.paidUpTo)}</div>
            ${actions}
          `;
          container.appendChild(div);
        });

      // Wire admin buttons
      container.querySelectorAll('button[data-action="record"]').forEach(btn => {
        btn.onclick = () => openPaymentModal(btn.getAttribute('data-id'));
      });
      container.querySelectorAll('button[data-action="remind"]').forEach(btn => {
        btn.onclick = () => generateReminder(btn.getAttribute('data-id'));
      });
    }

    async function loadLocalJsonMembers() {
      // On root page, JSON lives under docs/
      const res = await fetch('docs/cleaned_members_final.json', { cache: 'no-store' });
      if (!res.ok) throw new Error('Failed to load local JSON');
      const raw = await res.json();
      return raw.map(m => ({
        id: String(m.memberId || m.id || ''),
        memberId: m.memberId,
        fullName: m.fullName || m.name,
        isActive: m.isActive,
        startDate: (m.startDate || '') + (m.startDate && m.startDate.length === 7 ? '-01' : ''),
        payments: m.payments || m.paymentsDues || {}
      }));
    }

    function attachRealtime() {
      const { db } = window.firebaseServices || {};
      if (!db) {
        alert('Firebase not initialized. Create docs/firebase-config.js from the example and reload.');
        return () => {};
      }

      return db.collection('members').onSnapshot(async (snap) => {
        let members = [];
        snap.forEach(doc => members.push({ id: doc.id, ...doc.data() }));

        // If Firestore has no docs OR no payments across all docs, fallback to local JSON
        const totalPayments = members.reduce((sum, m) => {
          const p = m.payments || {};
          return sum + Object.values(p).reduce((s, v) => s + Number(v || 0), 0);
        }, 0);
        const needsFallback = (!members.length) || (totalPayments === 0);
        if (needsFallback) {
          try {
            const res = await fetch('docs/cleaned_members_final.json', { cache: 'no-store' });
            if (res.ok) {
              const raw = await res.json();
              // Transform JSON schema -> v2 schema
              members = raw.map(m => {
                const payments = m.payments || m.paymentsDues || {};
                return {
                  id: String(m.memberId || m.id || ''),
                  memberId: m.memberId,
                  fullName: m.fullName || m.name,
                  isActive: m.isActive,
                  startDate: (m.startDate || '') + (m.startDate && m.startDate.length === 7 ? '-01' : ''),
                  payments: payments
                };
              });
            }
          } catch (e) { console.warn('JSON fallback load failed', e); }
        }

        window.__members = members;
        renderStats(members);
        renderList(members);
      }, async (err) => {
        console.warn('onSnapshot error; falling back to local JSON', err);
        try {
          const res = await fetch('docs/cleaned_members_final.json', { cache: 'no-store' });
          if (res.ok) {
            const raw = await res.json();
            const members = raw.map(m => {
              const payments = m.payments || m.paymentsDues || {};
              return {
                id: String(m.memberId || m.id || ''),
                memberId: m.memberId,
                fullName: m.fullName || m.name,
                isActive: m.isActive,
                startDate: (m.startDate || '') + (m.startDate && m.startDate.length === 7 ? '-01' : ''),
                payments
              };
            });
            window.__members = members;
            renderStats(members);
            renderList(members);
          } else {
            console.error('Fallback JSON load failed', res.status);
          }
        } catch (e) {
          console.error('Fallback JSON exception', e);
        }
      });
    }

    // Subscribe to a single member document (member-only view)
    function attachMemberRealtime(memberId) {
      const { db } = window.firebaseServices || {};
      if (!db || !memberId) return () => {};
      return db.collection('members').doc(String(memberId)).onSnapshot((doc) => {
        const container = document.getElementById('list');
        if (!doc.exists) {
          container.innerHTML = '<div class="muted">No record found.</div>';
          document.getElementById('statTotal').textContent = '—';
          document.getElementById('statCurrent').textContent = '—';
          document.getElementById('statBehind').textContent = '—';
          document.getElementById('statOwed').textContent = '—';
          return;
        }
        const m = { id: doc.id, ...doc.data() };
        container.innerHTML = '';
        const f = calculateMemberFinancials(m);
        const statusClass = (f.status === 'current' || f.status === 'ahead') ? 'current' : 'behind';
        const balanceEl = f.balance < 0 ? `<span class="warn">-$${Math.abs(f.balance).toFixed(2)}</span>` : `<span class="green">$${f.balance.toFixed(2)}</span>`;
        const div = document.createElement('div');
        div.className = 'member';
        const startChip = f.startAt ? 
          `Start: ${f.startAt.toLocaleString('en-US', { month: 'short', year: 'numeric', timeZone: 'UTC' })}` : 
          'Start: —';
        div.innerHTML = `
          <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n\
            <div>\n\
              <div style=\"font-weight:600;\">${m.fullName || 'Unnamed'}</div>\n\
              <div class=\"muted\">Member ID: ${m.memberId || '—'}</div>\n\
            </div>\n\
            <span class=\"badge ${statusClass}\">${f.status}</span>\n\
          </div>\n\
          <div class=\"muted\" style=\"margin-top:6px;\">${startChip} • Balance: ${balanceEl} • Months behind: ${f.monthsBehind} • Paid up to: ${formatPaidUpTo(f.paidUpTo)}</div>\n\
        `;
        container.appendChild(div);
        // Hide global stats for member-only view
        document.getElementById('statTotal').textContent = '—';
        document.getElementById('statCurrent').textContent = '—';
        document.getElementById('statBehind').textContent = '—';
        document.getElementById('statOwed').textContent = '—';
      }, (err) => { console.warn('member onSnapshot error', err); });
    }

    function setupAuth() {
      const { auth, db } = window.firebaseServices || {};
      if (!auth) return;
      const signInEmailBtn = document.getElementById('btnSignInEmail');
      const claimPhoneIdBtn = document.getElementById('btnClaimPhoneId');
      const signOutBtn = document.getElementById('btnSignOut');
      // Anonymous sign-in disabled
      signInEmailBtn.onclick = async () => {
        const email = prompt('Enter email:');
        if (!email) return;
        const password = prompt('Enter password:');
        if (!password) return;
        try { await auth.signInWithEmailAndPassword(email, password); }
        catch(e){ alert('Email sign-in failed: ' + (e && e.message ? e.message : e)); }
      };
      // Passwordless phone+ID claim (no SMS): anonymous auth + verify against members/{memberId}
      claimPhoneIdBtn.onclick = async () => {
        const phoneRaw = prompt('Enter your phone (digits only or +1...):');
        if (!phoneRaw) return;
        const memberId = prompt('Enter your member ID (number):');
        if (!memberId) return;
        const normalize = (p) => {
          let s = String(p).trim();
          if (s.startsWith('+')) return '+' + s.slice(1).replace(/\D+/g, '');
          s = s.replace(/\D+/g, '');
          if (s.length === 10) return '+1' + s;
          return s.startsWith('+') ? s : ('+' + s);
        };
        const phone = normalize(phoneRaw);
        try {
          if (!auth.currentUser) await auth.signInAnonymously();
        } catch(_){}
        try {
          const { db } = window.firebaseServices || {};
          const doc = await db.collection('members').doc(String(memberId)).get();
          if (!doc.exists) { alert('Member not found'); return; }
          const m = doc.data() || {};
          const stored = (m.phone || m.phoneNumber || '').toString();
          const storedNorm = normalize(stored);
          if (!storedNorm || storedNorm !== phone) {
            alert('Phone does not match our records.');
            return;
          }
          // Link this anon user to member role for this session by writing roles/{uid}
          const uid = auth.currentUser && auth.currentUser.uid;
          if (!uid) { alert('Auth not ready'); return; }
          // Write the exact stored phone string for rules equality check
          await db.collection('roles').doc(uid).set({ role: 'member', memberId: String(memberId), phone: stored }, { merge: true });
          alert('Verified. Loading your account...');
          // Force re-subscribe with member-only view
          if (typeof unsubscribe === 'function') try { unsubscribe(); } catch(_){ }
          window.__role = 'member';
          window.__memberId = String(memberId);
          unsubscribe = attachMemberRealtime(String(memberId));
        } catch (e) {
          alert('Claim failed: ' + (e && e.message ? e.message : e));
        }
      };
      signOutBtn.onclick = async () => { try { await auth.signOut(); } catch(e){ alert('Signout failed'); } };
      auth.onAuthStateChanged(async user => {
        const showSignedOut = user ? 'none' : '';
        if (signInEmailBtn) signInEmailBtn.style.display = showSignedOut;
        if (claimPhoneIdBtn) claimPhoneIdBtn.style.display = showSignedOut;
        signOutBtn.style.display = user ? '' : 'none';
        // Load role document if signed in
        try {
          window.__role = 'member';
          window.__memberId = null;
          if (user && db) {
            const snap = await db.collection('roles').doc(user.uid).get();
            if (snap.exists && snap.data() && snap.data().role) {
              window.__role = snap.data().role;
              if (snap.data().memberId) window.__memberId = String(snap.data().memberId);
            }
          }
          const badge = document.getElementById('roleBadge');
          if (badge) badge.textContent = user ? `Role: ${window.__role}` : '';
        } catch(e) { 
          window.__role = 'member'; 
          window.__memberId = null; 
          const badge = document.getElementById('roleBadge'); 
          if (badge) badge.textContent = ''; 
        }
        if (window.__members) renderList(window.__members);
        // When logged out, hide list for security
        if (!user) {
          const container = document.getElementById('list');
          if (container) container.innerHTML = '';
          document.getElementById('statTotal').textContent = '—';
          document.getElementById('statCurrent').textContent = '—';
          document.getElementById('statBehind').textContent = '—';
          document.getElementById('statOwed').textContent = '—';
        }
      });
    }

    let unsubscribe = null;
    window.addEventListener('DOMContentLoaded', async () => {
      setupAuth();
      if (USE_LOCAL_ONLY) {
        try {
          const members = await loadLocalJsonMembers();
          window.__members = members;
          renderStats(members);
          renderList(members);
        } catch (e) { console.error(e); }
        return;
      }

      const { auth } = window.firebaseServices || {};
      if (auth) {
        auth.onAuthStateChanged(async () => {
          if (unsubscribe) try { unsubscribe(); } catch(_){ }
          if (auth.currentUser) {
            if (window.__role === 'member' && window.__memberId) {
              unsubscribe = attachMemberRealtime(window.__memberId);
            } else {
              unsubscribe = attachRealtime();
            }
          } else {
            const container = document.getElementById('list');
            if (container) container.innerHTML = '';
            document.getElementById('statTotal').textContent = '—';
            document.getElementById('statCurrent').textContent = '—';
            document.getElementById('statBehind').textContent = '—';
            document.getElementById('statOwed').textContent = '—';
          }
        });
      } else {
        try {
          const members = await loadLocalJsonMembers();
          window.__members = members;
          renderStats(members);
          renderList(members);
        } catch(_){ }
      }
      document.getElementById('refresh').onclick = () => {
        if (window.__members) {
          renderStats(window.__members);
          renderList(window.__members);
        }
      };
      document.getElementById('search').addEventListener('input', () => {
        if (window.__members) renderList(window.__members);
      });
      document.getElementById('filterStatus').addEventListener('change', () => {
        if (window.__members) renderList(window.__members);
      });
      // Payment modal handlers
      document.getElementById('pcancel').onclick = closePaymentModal;
      document.getElementById('psave').onclick = savePayment;
    });

    window.addEventListener('unload', () => { if (typeof unsubscribe === 'function') unsubscribe(); });

    // --- Admin: Record Payment & Reminder ---
    function findMemberById(id) {
      return (window.__members || []).find(m => String(m.id) === String(id));
    }

    function openPaymentModal(memberId) {
      const m = findMemberById(memberId);
      if (!m) return alert('Member not found');
      document.getElementById('pmember').textContent = `${m.fullName} (ID ${m.memberId || m.id})`;
      document.getElementById('pamount').value = '';
      document.getElementById('ptype').value = 'monthly';
      document.getElementById('ppreview').textContent = '';
      const modal = document.getElementById('paymentModal');
      modal.style.display = 'flex';
      modal.setAttribute('data-id', m.id);
    }

    function closePaymentModal() {
      const modal = document.getElementById('paymentModal');
      modal.style.display = 'none';
      modal.removeAttribute('data-id');
    }

    function distributeToUnpaidMonths(amount, payments) {
      const map = { ...(payments || {}) };
      let remaining = Number(amount) || 0;
      const iter = new Date(Date.UTC(2022,0,1));
      const end = new Date(Date.UTC(CURRENT_DATE.getUTCFullYear(), CURRENT_DATE.getUTCMonth(), 1));
      while (iter <= end && remaining >= DUE_PER_MONTH) {
        const key = monthKey(iter);
        const paid = Number(map[key] || 0);
        if (paid < DUE_PER_MONTH) {
          const need = DUE_PER_MONTH - paid;
          const apply = Math.min(need, remaining);
          map[key] = paid + apply;
          remaining -= apply;
        }
        iter.setUTCMonth(iter.getUTCMonth() + 1);
      }
      // If still remaining, allocate into future months sequentially
      let future = new Date(Date.UTC(CURRENT_DATE.getUTCFullYear(), CURRENT_DATE.getUTCMonth()+1, 1));
      while (remaining >= DUE_PER_MONTH) {
        const key = monthKey(future);
        const paid = Number(map[key] || 0);
        const need = Math.max(0, DUE_PER_MONTH - paid);
        const apply = Math.min(need || DUE_PER_MONTH, remaining);
        map[key] = paid + apply;
        remaining -= apply;
        future.setUTCMonth(future.getUTCMonth() + 1);
      }
      return { map, remaining };
    }

    async function savePayment() {
      const { db, auth } = window.firebaseServices || {};
      if (!db) return alert('Firebase not initialized');
      const modal = document.getElementById('paymentModal');
      const memberId = modal.getAttribute('data-id');
      const m = findMemberById(memberId);
      if (!m) return alert('Member not found');
      const amount = Number(document.getElementById('pamount').value || 0);
      const type = document.getElementById('ptype').value;
      if (!(amount > 0)) return alert('Enter a valid amount');

      try {
        const docRef = db.collection('members').doc(String(m.id));
        if (type === 'monthly') {
          const dist = distributeToUnpaidMonths(amount, m.payments || {});
          await docRef.set({ payments: dist.map }, { merge: true });
        } else {
          // For incidental/registration we log to an array field for now
          const field = type === 'registration' ? 'registrationPayments' : 'incidentalPayments';
          const entry = { amount, at: new Date().toISOString(), by: (auth && auth.currentUser && auth.currentUser.email) || 'admin' };
          const payload = {};
          payload[field] = firebase.firestore.FieldValue.arrayUnion(entry);
          await docRef.set(payload, { merge: true });
        }
        closePaymentModal();
      } catch (e) {
        console.error(e);
        alert('Failed to save payment');
      }
    }

    async function generateReminder(memberId) {
      const m = findMemberById(memberId);
      if (!m) return alert('Member not found');
      const f = calculateMemberFinancials(m);
      const owed = f.balance < 0 ? Math.abs(f.balance).toFixed(2) : '0.00';
      const msg = `ሰላም ${m.fullName},\n\nበአሁኑ ጊዜ የወርሃዊ ክፍያ ቀሪ ዕለት $${owed} አለ። እባክዎ ክፍያውን በተመጣጣኝ ጊዜ ይፈፅሙ።\n\nእናመሰግናለን!`;
      try { await navigator.clipboard.writeText(msg); alert('Reminder copied to clipboard'); } catch(_) { alert('Could not copy to clipboard'); }
    }
  </script>
</body>
</html>


